# АК: Лабораторная работа №3. Эксперимент.

- Лукьянчук Ярослав Евгеньевич P3223
- asm | risc | harv | mc | instr | binary | stream | port | cstr | prob2

---

## Язык программирования SwagLang

```bnf
<program> ::= <data_section> <text_section>

<data_section> ::= "data:" "{" {<data_definition>}* "}"

<data_definition> ::= <label> ":" <data_value> ";"

<data_value> ::= <string_literal> | <number>

<string_literal> ::= '"' {<char>}* '"'

<number> ::= <digit> {<digit>}*

<text_section> ::= "run" <block>

<block> ::= ":{" {<instruction>}* "}"

<instruction> ::= <label> ":" <block>
                | <label> ":" 
                | <command> ";"

<command> ::= "load" "[" <reg> "," <value_or_address> "]"
            | "store" "[" <reg> "," <address> "]"
            | "input" "[" <reg> "," <stream> "]"
            | "output" "[" <reg> "," <stream> "]"
            | "inputchar" "[" <reg> "," <stream> "]"
            | "outputchar" "[" <reg> "," <stream> "]"
            | "add" "[" <reg> "," <reg_or_value> "]"
            | "sub" "[" <reg> "," <reg_or_value> "]"
            | "cmp" "[" <reg> "," <reg_or_value> "]"
            | "jmp" "[" <label> "]"
            | "je" "[" <label> "]"
            | "jne" "[" <label> "]"
            | "stop"

<reg> ::= "R1" | "R2" | "R3"

<value_or_address> ::= <number> | <address>

<address> ::= <label>

<stream> ::= "!" <label>

<label> ::= <letter> {<letter> | <digit>}*

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "a" | ... | "z" | "A" | ... | "Z"

<char> ::= <letter> | <digit> | <special_char>

<special_char> ::= "!" | "\"" | "#" | "$" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "\\" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~"
```

---

## 2. Описание команд

### 2.1 Операции с регистрами и памятью

#### **`load[reg, value_or_address]`**

Загружает числовое значение или значение из памяти по указанному адресу в регистр.

**Пример:**

```asm
load[R1, 100];          // R1 = 100
load[R3, myVar];        // R3 = значение переменной myVar из секции данных
```

#### **`store[reg, address]`**

Сохраняет значение из регистра по указанному адресу памяти.

**Пример:**

```asm
store[R1, sum];         // Сохраняем значение из R1 в переменную sum
```

#### **`add[reg, reg_or_value]`**

Прибавляет значение к регистру.

**Пример:**

```asm
add[R1, 10];            // R1 = R1 + 10
add[R2, R1];            // R2 = R2 + R1
```

#### **`sub[reg, reg_or_value]`**

Вычитает значение из регистра.

**Пример:**

```asm
sub[R2, 1];             // R2 = R2 - 1
sub[R3, R1];            // R3 = R3 - R1
```

#### **`cmp[reg, reg_or_value]`**

Сравнивает значение в регистре с другим значением; результат влияет на последующие условные переходы.

**Пример:**

```asm
cmp[R1, 0];             // Сравниваем R1 с 0
cmp[R2, R3];            // Сравниваем R2 с R3
```

### 2.2 Ввод и вывод данных

#### **`input[reg, !stream]`**

Считывает числовое значение из потока в регистр.

**Пример:**

```asm
input[R2, !INPUT];      // Считываем число из потока INPUT в R2
```

#### **`output[reg, !stream]`**

Выводит числовое значение из регистра в поток.

**Пример:**

```asm
output[R3, !OUTPUT];    // Выводим число из R3 в поток OUTPUT
```

### 2.3 Работа с символами

#### **`inputchar[reg, !stream]`**

Считывает один символ из потока и сохраняет его в регистр.

**Пример:**

```asm
inputchar[R1, !INPUT];   // Считываем символ из потока INPUT в R1
```

#### **`outputchar[reg, !stream]`**

Выводит один символ из регистра в поток.

**Пример:**

```asm
outputchar[R2, !OUTPUT]; // Выводим символ из R2 в поток OUTPUT
```

### 2.4 Переходы и метки

#### **Безусловный переход:**

**`jmp[метка]`**

Переходит к указанной метке без условий.

**Пример:**

```asm
jmp[loop_start];        // Переход к метке loop_start
```

#### **Условные переходы (после `cmp`):**

- **`je[метка]`** — переход, если значения равны.

  **Пример:**

  ```asm
  je[exit_loop];        // Переход к exit_loop, если значения равны
  ```

- **`jne[метка]`** — переход, если значения не равны.

  **Пример:**

  ```asm
  jne[loop_start];      // Переход к loop_start, если значения не равны
  ```

- **`jg[метка]`** — переход, если первое значение больше второго.

  **Пример:**

  ```asm
  jg[greater];          // Переход к greater, если первое значение больше
  ```

- **`jl[метка]`** — переход, если первое значение меньше второго.

  **Пример:**

  ```asm
  jl[less];             // Переход к less, если первое значение меньше
  ```

---

## 3. Описание семантики

### 3.1 Последовательное выполнение

Программа выполняется сверху вниз, команда за командой, если поток управления не изменяется с помощью переходов. Каждая команда выполняется полностью перед переходом к следующей.

### 3.2 Условные и безусловные переходы

- **Безусловные переходы** (`jmp`) позволяют изменить поток выполнения программы без каких-либо условий.
- **Условные переходы** (`je`, `jne`, `jg`, `jl`) основываются на результате последнего сравнения с помощью команды `cmp`. Если условие выполняется, происходит переход к указанной метке; иначе выполнение продолжается последовательно.

### 3.3 Циклы

Циклы создаются с использованием меток и переходов. Используя условные переходы и метки, можно реализовать различные структуры циклов, такие как `while`, `for` и `do-while`.

**Пример цикла:**

```asm
run {
    load[R1, 0];                 // Инициализируем R1 = 0
    input[R2, !INPUT];           // Считываем число в R2

    loop_start: {
        cmp[R2, 0];              // Проверяем, не равен ли R2 нулю
        je[exit_loop];           // Если R2 == 0, выходим из цикла

        add[R1, 1];              // Увеличиваем R1 на 1
        sub[R2, 1];              // Уменьшаем R2 на 1
        jmp[loop_start];         // Переходим к началу цикла
    };

    exit_loop: {
        output[R1, !OUTPUT];     // Выводим результат R1
    };
}
```

---

## 4. Области видимости

- **Регистры**: глобальные, доступны всем командам в программе. Значения, хранящиеся в регистрах, сохраняются между командами и могут быть изменены в любой части программы.

- **Метки**: глобальные, могут быть использованы для переходов из любого места программы. Метки объявляются путем указания идентификатора, за которым следует двоеточие `:`. Если метка сопровождается блоком `{...}`, то это считается отдельным блоком команд, но область видимости метки все равно глобальна.

- **Память**: переменные, определенные в секции данных, имеют глобальную область видимости. Обращение к данным в памяти осуществляется по именам переменных, указанным в командах `load` и `store`.

---

## 5. Виды литералов

### 5.1 Целочисленные литералы

- **Десятичные числа**: последовательность цифр от `0` до `9`. (в рамках 9 бит)

  **Пример:**

  ```asm
  load[R1, 100];      // Десятичное число 100
  ```

### 5.2 Строковые литералы

Строковые литералы определяются в секции данных и заключаются в двойные кавычки `"..."`.

**Пример:**

```asm
data {
    greeting: "Hello, World!";
}
```

### 5.3 Идентификаторы

- **Метки**: используются для обозначения точек в коде, к которым можно перейти с помощью команд перехода.

- **Имена потоков**: идентификаторы, предшествующие символом `!`, используются для обозначения потоков ввода и вывода.

- **Переменные**: определяются в секции данных и используются для хранения числовых значений или строк.

**Пример:**

```asm
input[R2, !INPUT];   // INPUT — идентификатор потока
loop_start: { ... }  // loop_start — метка
load[R1, myVar];     // myVar — переменная из секции данных
```

---

## 6. Секция данных

Секция данных используется для определения констант и переменных, которые могут быть использованы в программе. Она объявляется после основной программы с помощью ключевого слова `data`.

**Пример:**

```asm
data {
    myVar: 10;
    greeting: "Hello, World!";
}
```

- **`myVar`** — переменная, содержащая число `10`.
- **`greeting`** — строковая переменная со значением `"Hello, World!"`.

---

## 7. Пример полной программы

**Задача:** Считать строку из входного потока посимвольно, сохранить ее в памяти, затем вывести ее обратно в выходной поток.

```asm
run {
    // Инициализация
    load[R1, 0];                 // R1 будет использоваться как указатель в строке

    read_loop: {
        readchar[R2, !INPUT];    // Считываем символ в R2
        cmp[R2, 0];              // Проверяем, не достигнут ли конец строки (символ 0)
        je[write_loop];          // Если символ 0, переходим к выводу

        store[str + R1, R2];     // Сохраняем символ в памяти по адресу str + R1
        add[R1, 1];              // Увеличиваем указатель R1
        jmp[read_loop];          // Переходим к началу цикла чтения
    };

    write_loop: {
        load[R1, 0];             // Сброс указателя R1 для чтения из начала строки
    };

    output_loop: {
        load[R2, str + R1];      // Загружаем символ из памяти по адресу str + R1
        cmp[R2, 0];              // Проверяем, не достигнут ли конец строки
        je[end];                 // Если символ 0, завершаем программу

        writechar[R2, !OUTPUT];  // Выводим символ в поток OUTPUT
        add[R1, 1];              // Увеличиваем указатель R1
        jmp[output_loop];        // Переходим к началу цикла вывода
    };

    end: {
        // Программа завершена
    };
}

data {
    str: 0;                      // Начальный адрес для хранения строки
}
```

**Пояснение:**

1. **Инициализация:**

   - `R1 = 0` — используется как указатель для доступа к массиву символов в памяти.

2. **Цикл чтения (`read_loop`):**

   - Считываем символ из потока `INPUT` в `R2`.
   - Если считан символ `0` (конец строки), переходим к метке `write_loop`.
   - Сохраняем символ из `R2` в памяти по адресу `str + R1`.
   - Увеличиваем `R1` на `1` для перехода к следующему месту в памяти.
   - Переходим обратно к началу цикла `read_loop`.

3. **Подготовка к выводу:**

   - Сбрасываем `R1` в `0` для чтения из начала строки.

4. **Цикл вывода (`output_loop`):**

   - Загружаем символ из памяти по адресу `str + R1` в `R2`.
   - Если символ `0`, переходим к метке `end`.
   - Выводим символ из `R2` в поток `OUTPUT`.
   - Увеличиваем `R1` на `1`.
   - Переходим обратно к началу цикла `output_loop`.

5. **Завершение программы:**

   - Метка `end` обозначает конец программы.

---
## Микрокод