# АК: Лаборатроная работа №3. Эксперимент.

- Лукьянчук Ярослав Евгеньевич P3223
- asm | risc | harv | mc | instr | binary | stream | port | cstr | prob2 

---

## Язык программирования SwagLang

```bnf
<program>    ::= "run" <block>

<block>      ::= "{" <commands> "}"

<commands>   ::= <command> <commands> | ε

<command>    ::= <operation> ";" 
               | <jump> ";" 
               | <label> ":" <block> 
               | <label> ":" ";" 
               | ε

<operation>  ::= <load> 
               | <input> 
               | <output> 
               | <add> 
               | <sub> 
               | <cmp> 
               | <readstr> 
               | <writestr> 
               | <readchar> 
               | <storestr> 
               | <loadstr>
               | <storemem>
               | <loadmem>

<load>       ::= "load" "[" <reg> "," <value> "]"

<input>      ::= "input" "[" <reg> "," <stream> "]"

<output>     ::= "output" "[" <reg> "," <stream> "]"

<add>        ::= "add" "[" <reg> "," <reg_or_value> "]"

<sub>        ::= "sub" "[" <reg> "," <reg_or_value> "]"

<cmp>        ::= "cmp" "[" <reg> "," <reg_or_value> "]"

<readstr>    ::= "readstr" "[" <reg> "," <stream> "]"

<writestr>   ::= "writestr" "[" <reg> "," <stream> "]"

<readchar>   ::= "readchar" "[" <dest_reg> "," <source_reg> "]"

<storestr>   ::= "storestr" "[" <address> "," <reg> "]"

<loadstr>    ::= "loadstr" "[" <reg> "," <address> "]"

<storemem>   ::= "storemem" "[" <address> "," <reg> "]"

<loadmem>    ::= "loadmem" "[" <reg> "," <address> "]"

<jump>       ::= "jmp" "[" <identifier> "]"
               | "je" "[" <identifier> "]"
               | "jne" "[" <identifier> "]"
               | "jg" "[" <identifier> "]"
               | "jl" "[" <identifier> "]"

<label>      ::= <identifier>

<reg>        ::= "R1" | "R2" | "R3" | "R4" | "R5" | "R6"

<reg_or_value> ::= <reg> | <value>

<value>      ::= <integer> | <hex_value>

<stream>     ::= "!" <identifier>

<address>    ::= <hex_value>

<identifier> ::= <letter> {<letter> | <digit>}*

<letter>     ::= "A" | ... | "Z" | "a" | ... | "z"

<integer>    ::= <digit> {<digit>}*

<digit>      ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<hex_value>  ::= "0x" <hex_digit> {<hex_digit>}*

<hex_digit>  ::= <digit> | "A" | "B" | "C" | "D" | "E" | "F"
```

---

## 2. Описание команд

### 2.1 Операции с регистрами и памятью

#### **`load[reg, value]`**

Загружает числовое значение в указанный регистр.

**Пример:**

```asm
load[R1, 100];       // R1 = 100
load[R2, 0xFF];      // R2 = 255 (шестнадцатеричное значение)
```

#### **`add[reg, reg_or_value]`**

Прибавляет значение к регистру.

**Пример:**

```asm
add[R1, 10];         // R1 = R1 + 10
add[R2, R1];         // R2 = R2 + R1
```

#### **`sub[reg, reg_or_value]`**

Вычитает значение из регистра.

**Пример:**

```asm
sub[R2, 1];          // R2 = R2 - 1
sub[R3, R1];         // R3 = R3 - R1
```

#### **`cmp[reg, reg_or_value]`**

Сравнивает значение в регистре с другим значением; результат влияет на последующие условные переходы.

**Пример:**

```asm
cmp[R1, 0];          // Сравниваем R1 с 0
cmp[R2, R3];         // Сравниваем R2 с R3
```

#### **`storemem[address, reg]`**

Сохраняет числовое значение из регистра по указанному адресу памяти.

**Пример:**

```asm
storemem[0x100, R1]; // Сохраняем значение из R1 по адресу 0x100
```

#### **`loadmem[reg, address]`**

Загружает числовое значение из указанного адреса памяти в регистр.

**Пример:**

```asm
loadmem[R1, 0x100];  // Загружаем значение из адреса 0x100 в R1
```

### 2.2 Ввод и вывод данных

#### **`input[reg, !stream]`**

Считывает данные из потока в регистр.

**Пример:**

```asm
input[R2, !INPUT];   // Считываем данные из потока INPUT в R2
```

#### **`output[reg, !stream]`**

Выводит данные из регистра в поток.

**Пример:**

```asm
output[R3, !OUTPUT]; // Выводим данные из R3 в поток OUTPUT
```

### 2.3 Работа со строками

#### **`readstr[reg, !stream]`**

Считывает строку из потока в регистр до символа `\0`.

**Пример:**

```asm
readstr[R3, !INPUT]; // Считываем строку из потока INPUT в R3
```

#### **`writestr[reg, !stream]`**

Выводит строку из регистра в поток до символа `\0`.

**Пример:**

```asm
writestr[R2, !OUTPUT]; // Выводим строку из R2 в поток OUTPUT
```

#### **`readchar[dest_reg, source_reg]`**

Считывает один символ из строки в исходном регистре и сохраняет его в целевой регистр. Указатель позиции в строке автоматически увеличивается.

**Пример:**

```asm
readchar[R4, R3];     // Читаем символ из R3 и сохраняем в R4
```

#### **`storestr[address, reg]`**

Сохраняет строку из регистра по указанному адресу в памяти.

**Пример:**

```asm
storestr[0x200, R3];  // Сохраняем строку из R3 по адресу 0x200
```

#### **`loadstr[reg, address]`**

Загружает строку из памяти по указанному адресу в регистр.

**Пример:**

```asm
loadstr[R3, 0x200];   // Загружаем строку из адреса 0x200 в R3
```

### 2.4 Переходы и метки

#### **Безусловный переход:**

**`jmp[метка]`**

Переходит к указанной метке без условий.

**Пример:**

```asm
jmp[loop_start];      // Переход к метке loop_start
```

#### **Условные переходы (после `cmp`):**

- **`je[метка]`** — переход, если значения равны.

  **Пример:**

  ```asm
  je[exit_loop];      // Переход к exit_loop, если значения равны
  ```

- **`jne[метка]`** — переход, если значения не равны.

  **Пример:**

  ```asm
  jne[loop_start];    // Переход к loop_start, если значения не равны
  ```

- **`jg[метка]`** — переход, если первое значение больше второго.

  **Пример:**

  ```asm
  jg[greater];        // Переход к greater, если первое значение больше
  ```

- **`jl[метка]`** — переход, если первое значение меньше второго.

  **Пример:**

  ```asm
  jl[less];           // Переход к less, если первое значение меньше
  ```

---

## 3. Описание семантики

### 3.1 Последовательное выполнение

Программа выполняется сверху вниз, команда за командой, если поток управления не изменяется с помощью переходов. Каждая команда выполняется полностью перед переходом к следующей.

### 3.2 Условные и безусловные переходы

- **Безусловные переходы** (`jmp`) позволяют изменить поток выполнения программы без каких-либо условий.
- **Условные переходы** (`je`, `jne`, `jg`, `jl`) основываются на результате последнего сравнения с помощью команды `cmp`. Если условие выполняется, происходит переход к указанной метке; иначе выполнение продолжается последовательно.

### 3.3 Циклы

Циклы создаются с использованием меток и переходов. Используя условные переходы и метки, можно реализовать различные структуры циклов, такие как `while`, `for` и `do-while`.

**Пример цикла:**

```asm
run {
    load[R1, 0];                 // Инициализируем R1 = 0
    input[R2, !INPUT];           // Считываем число в R2

    loop_start: {
        cmp[R2, 0];              // Проверяем, не равен ли R2 нулю
        je[exit_loop];           // Если R2 == 0, выходим из цикла

        add[R1, 1];              // Увеличиваем R1 на 1
        sub[R2, 1];              // Уменьшаем R2 на 1
        jmp[loop_start];         // Переходим к началу цикла
    };

    exit_loop: {
        output[R1, !OUTPUT];     // Выводим результат R1
    };
}
```

В этом примере цикл продолжает выполняться, пока значение в R2 не станет равным нулю.

---

## 4. Области видимости

- **Регистры**: глобальные, доступны всем командам в программе. Значения, хранящиеся в регистрах, сохраняются между командами и могут быть изменены в любой части программы.

- **Метки**: глобальные, могут быть использованы для переходов из любого места программы. Метки объявляются путем указания идентификатора, за которым следует двоеточие `:`. Если метка сопровождается блоком `{...}`, то это считается отдельным блоком команд, но область видимости метки все равно глобальна.

- **Память**: адреса в памяти являются глобальными и могут быть использованы для хранения числовых значений или строк. Обращение к данным в памяти осуществляется по адресам, указанным в командах `storemem`, `loadmem`, `storestr`, `loadstr`.



## 5. Виды литералов

### 5.1 Целочисленные литералы

- **Десятичные числа**: последовательность цифр от `0` до `9`.

  **Пример:**

  ```asm
  load[R1, 100];      // Десятичное число 100
  ```

- **Шестнадцатеричные числа**: начинаются с `0x`, за которым следует последовательность шестнадцатеричных цифр (`0-9`, `A-F`).

  **Пример:**

  ```asm
  load[R2, 0x1A];     // Шестнадцатеричное число 26
  ```

### 5.2 Строковые литералы

Строковые литералы не используются напрямую в коде. Вместо этого строки считываются из потоков или памяти и обрабатываются с помощью специальных команд.

### 5.3 Идентификаторы

- **Метки**: используются для обозначения точек в коде, к которым можно перейти с помощью команд перехода.

- **Имена потоков**: идентификаторы, предшествующие символом `!`, используются для обозначения потоков ввода и вывода.

**Пример:**

```asm
input[R2, !INPUT];   // INPUT — идентификатор потока
loop_start: { ... }  // loop_start — метка
```

---

## 7. Пример полной программы

**Задача:** Считать число `n` из входного потока, затем считать `n` чисел и вычислить их сумму. После этого сохранить результат в память, затем загрузить его обратно и вывести в выходной поток.

```asm
run {
    // Инициализация
    load[R1, 0];                 // R1 будет содержать сумму
    input[R2, !INPUT];           // Считываем n в R2

    loop_start: {
        cmp[R2, 0];              // Проверяем, не равен ли R2 нулю
        je[after_loop];          // Если R2 == 0, переходим после цикла

        input[R3, !INPUT];       // Считываем очередное число в R3
        add[R1, R3];             // Добавляем R3 к сумме в R1
        sub[R2, 1];              // Уменьшаем счетчик R2
        jmp[loop_start];         // Переходим к началу цикла
    };

    after_loop: {
        storemem[0x300, R1];     // Сохраняем сумму R1 по адресу 0x300
    };

    // Восстанавливаем сумму из памяти и выводим
    loadmem[R4, 0x300];          // Загружаем сумму в R4
    output[R4, !OUTPUT];         // Выводим сумму R4
}
```

**Пошаговое выполнение программы:**

1. **Инициализация:**

   - `R1 = 0` (сумма)
   - `R2 = n` (количество чисел для суммирования)

2. **Начало цикла (`loop_start`):**

   - Сравниваем `R2` с `0`.
   - Если `R2 == 0`, переходим к `after_loop`.
   - Иначе продолжаем выполнение цикла.

3. **Тело цикла:**

   - Считываем число в `R3`.
   - Добавляем `R3` к `R1` (суммируем).
   - Уменьшаем `R2` на `1`.
   - Переходим к началу цикла (`loop_start`).

4. **Завершение цикла:**

   - Когда `R2 == 0`, переходим к `after_loop`.
   - Сохраняем сумму `R1` по адресу `0x300`.

5. **Восстановление и вывод:**

   - Загружаем значение из памяти по адресу `0x300` в `R4`.
   - Выводим значение `R4` в выходной поток.

---
